--1757. Перерабатываемые и нежирные продукты
https://leetcode.com/problems/recyclable-and-low-fat-products/description/
/*Напишите решение, чтобы найти идентификаторы продуктов с низким содержанием жира и пригодных для вторичной переработки.
Верните таблицу результатов в любом порядке.
Формат результата приведен в следующем примере.*/

/*+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| product_id  | int     |
| low_fats    | enum    |
| recyclable  | enum    |
+-------------+---------+

Input: 
Products table:
+-------------+----------+------------+
| product_id  | low_fats | recyclable |
+-------------+----------+------------+
| 0           | Y        | N          |
| 1           | Y        | Y          |
| 2           | N        | Y          |
| 3           | Y        | Y          |
| 4           | N        | N          |
+-------------+----------+------------+
Output: 
+-------------+
| product_id  |
+-------------+
| 1           |
| 3           |
+-------------+
Explanation: Only products 1 and 3 are both low fat and recyclable.*/

Select product_id
FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y';
--------------------------------------------------------------------

--1741. Найдите общее время, потраченное каждым сотрудником
https://leetcode.com/problems/find-total-time-spent-by-each-employee/

/*Напишите решение для расчета общего времени в минутах, затрачиваемого каждым сотрудником на каждый день в офисе. 
Обратите внимание, что в течение одного дня сотрудник может входить и уходить более одного раза. Время, 
проведенное в офисе для одной записи, - out_time - in_time.
Input: 
Employees table:
+--------+------------+---------+----------+
| emp_id | event_day  | in_time | out_time |
+--------+------------+---------+----------+
| 1      | 2020-11-28 | 4       | 32       |
| 1      | 2020-11-28 | 55      | 200      |
| 1      | 2020-12-03 | 1       | 42       |
| 2      | 2020-11-28 | 3       | 33       |
| 2      | 2020-12-09 | 47      | 74       |
+--------+------------+---------+----------+
Output: 
+------------+--------+------------+
| day        | emp_id | total_time |
+------------+--------+------------+
| 2020-11-28 | 1      | 173        |
| 2020-11-28 | 2      | 30         |
| 2020-12-03 | 1      | 41         |
| 2020-12-09 | 2      | 27         |
+------------+--------+------------+
Explanation: */

SELECT
    event_day AS day,
    emp_id,
    SUM(out_time - in_time) AS total_time
FROM Employees
GROUP BY 
    emp_id,
    day;

------------------------------------------------------------------

--182. Дублирующие Электронные Письма
https://leetcode.com/problems/duplicate-emails/description/

/*Напишите решение, чтобы сообщить обо всех дубликатах электронных писем. Обратите внимание, что гарантировано, что поле электронной почты не является NULL.

Верните таблицу результатов в любом порядке.

Input: 
Person table:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
Output: 
+---------+
| Email   |
+---------+
| a@b.com |
+---------+*/

SELECT email AS Email
FROM Person
GROUP BY email
HAVING COUNT(*) > 1;

---------------------------------------------------------------

--количества уникальных предметов, которые каждый учитель преподает в университете
https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/

/*Напишите решение для расчета количества уникальных предметов, которые каждый учитель преподает в университете.
Верните таблицу результатов в любом порядке.

Teacher table:
+------------+------------+---------+
| teacher_id | subject_id | dept_id |
+------------+------------+---------+
| 1          | 2          | 3       |
| 1          | 2          | 4       |
| 1          | 3          | 3       |
| 2          | 1          | 1       |
| 2          | 2          | 1       |
| 2          | 3          | 1       |
| 2          | 4          | 1       |
+------------+------------+---------+
Output:  
+------------+-----+
| teacher_id | cnt |
+------------+-----+
| 1          | 2   |
| 2          | 4   |
+------------+-----+*/

SELECT
    teacher_id,
    COUNT(DISTINCT subject_id) AS cnt
FROM Teacher
GROUP BY
    teacher_id;

--------------------------------------------------------------

--1693. Ежедневные лидеры и партнеры
https://leetcode.com/problems/daily-leads-and-partners/


/*Для каждого date_id и make_name найдите количество различных lead_id и разных partner_id.

Верните таблицу результатов в любом порядке.

Input: 
DailySales table:
+-----------+-----------+---------+------------+
| date_id   | make_name | lead_id | partner_id |
+-----------+-----------+---------+------------+
| 2020-12-8 | toyota    | 0       | 1          |
| 2020-12-8 | toyota    | 1       | 0          |
| 2020-12-8 | toyota    | 1       | 2          |
| 2020-12-7 | toyota    | 0       | 2          |
| 2020-12-7 | toyota    | 0       | 1          |
| 2020-12-8 | honda     | 1       | 2          |
| 2020-12-8 | honda     | 2       | 1          |
| 2020-12-7 | honda     | 0       | 1          |
| 2020-12-7 | honda     | 1       | 2          |
| 2020-12-7 | honda     | 2       | 1          |
+-----------+-----------+---------+------------+
Output: 
+-----------+-----------+--------------+-----------------+
| date_id   | make_name | unique_leads | unique_partners |
+-----------+-----------+--------------+-----------------+
| 2020-12-8 | toyota    | 2            | 3               |
| 2020-12-7 | toyota    | 1            | 2               |
| 2020-12-8 | honda     | 2            | 2               |
| 2020-12-7 | honda     | 3            | 2               |
+-----------+-----------+--------------+-----------------+*/


SELECT
    date_id,
    make_name,
    COUNT(DISTINCT lead_id) AS unique_leads,
    COUNT(DISTINCT partner_id) AS unique_partners
FROM DailySales
GROUP BY
    date_id,
    make_name;

---------------------------------------------------------------------------

--1795. Переставить таблицу товаров.
https://leetcode.com/problems/rearrange-products-table/description/

/*Product_id - это первичный ключ (столбец с уникальными значениями) для этой таблицы.

Каждая строка в этой таблице показывает цену товара в 3 разных магазинах: store1, store2 и store3.

Если товар недоступен в магазине, цена будет нулевой в столбце этого магазина.

Напишите решение, чтобы переупорядочить таблицу "Продукты" так, чтобы в каждой строке было (product_id, store, price). Если продукт недоступен в магазине, не включайте строку с этой комбинацией product_id и store в таблицу результатов.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Products table:
+------------+--------+--------+--------+
| product_id | store1 | store2 | store3 |
+------------+--------+--------+--------+
| 0          | 95     | 100    | 105    |
| 1          | 70     | null   | 80     |
+------------+--------+--------+--------+
Output: 
+------------+--------+-------+
| product_id | store  | price |
+------------+--------+-------+
| 0          | store1 | 95    |
| 0          | store2 | 100   |
| 0          | store3 | 105   |
| 1          | store1 | 70    |
| 1          | store3 | 80    |
+------------+--------+-------+
*/

SELECT
    product_id,
    'store1' AS store,
    store1 AS price
FROM Products
WHERE store1 IS NOT NULL

UNION

SELECT
    product_id,
    'store2' AS store,
    store2 AS price
FROM Products
WHERE store2 IS NOT NULL

UNION

SELECT
    product_id,
    'store3' AS store,
    store3 AS price
FROM Products
WHERE store3 IS NOT NULL
---------------------------------------------------------------

--1683. Неверные твиты
https://leetcode.com/problems/invalid-tweets/

/*
Tweet_id является первичным ключом (столбец с уникальными значениями) для этой таблицы.

Эта таблица содержит все твиты в приложении для социальных сетей.

Напишите решение, чтобы найти идентификаторы недействительных твитов. Твит недействителен, если количество символов, используемых в содержании твита, строго больше 15.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Tweets table:
+----------+----------------------------------+
| tweet_id | content                          |
+----------+----------------------------------+
| 1        | Vote for Biden                   |
| 2        | Let us make America great again! |
+----------+----------------------------------+
Output: 
+----------+
| tweet_id |
+----------+
| 2        |
+----------+
*/

SELECT
    tweet_id
FROM Tweets
WHERE CHAR_LENGTH(content) > 15
-------------------------------------------------

--1587. Резюме банковского счета II.
https://leetcode.com/problems/bank-account-summary-ii/

/*
Напишите решение, чтобы сообщить имя и баланс пользователей с балансом более 10000. Баланс счета равен сумме всех транзакций, связанных с этим счетом.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Users table:
+------------+--------------+
| account    | name         |
+------------+--------------+
| 900001     | Alice        |
| 900002     | Bob          |
| 900003     | Charlie      |
+------------+--------------+
Transactions table:
+------------+------------+------------+---------------+
| trans_id   | account    | amount     | transacted_on |
+------------+------------+------------+---------------+
| 1          | 900001     | 7000       |  2020-08-01   |
| 2          | 900001     | 7000       |  2020-09-01   |
| 3          | 900001     | -3000      |  2020-09-02   |
| 4          | 900002     | 1000       |  2020-09-12   |
| 5          | 900003     | 6000       |  2020-08-07   |
| 6          | 900003     | 6000       |  2020-09-07   |
| 7          | 900003     | -4000      |  2020-09-11   |
+------------+------------+------------+---------------+
Output: 
+------------+------------+
| name       | balance    |
+------------+------------+
| Alice      | 11000      |
+------------+------------+
*/

SELECT
    name,
    SUM(amount) AS balance
FROM Transactions
LEFT JOIN Users
ON Transactions.account = Users.account
GROUP BY
    name
HAVING SUM(amount) > 10000;
------------------------------------------------------

--627. Обмен зарплаты
https://leetcode.com/problems/swap-salary/

/*
Напишите решение для замены всех значений 'f' и 'm' (т.е. изменить все значения 'f' на 'm' и наоборот) с одним оператором обновления и без промежуточных временных таблиц.

Обратите внимание, что вы должны написать одно заявление об обновлении, не пишите никакого заявления о выборе для этой проблемы.

Формат результата приведен в следующем примере.

Input: 
Salary table:
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
+----+------+-----+--------+
Output: 
+----+------+-----+--------+
| id | name | sex | salary |
+----+------+-----+--------+
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
+----+------+-----+--------+
Explanation: 
*/

UPDATE Salary
SET sex = CASE
    WHEN sex = 'm' THEN 'f'
    WHEN sex = 'f' THEN 'm'
    ELSE sex
END;
--------------------------------------------------------

--1378. Замените идентификатор сотрудника уникальным идентификатором.
https://translate.google.nl/?hl=ru&sl=auto&tl=ru&text=1378.%20Replace%20Employee%20ID%20With%20The%20Unique%20Identifier&op=translate

/*
Напишите решение, чтобы показать уникальный идентификатор каждого пользователя. Если у пользователя нет уникального идентификатора, просто покажите null.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+
EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+
Output: 
+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+
*/

SELECT
    unique_id,
    name
FROM Employees
LEFT JOIN EmployeeUNI
ON Employees.id = EmployeeUNI.id;
------------------------------------------------------------------

--1068. Анализ продаж продукции I
https://leetcode.com/problems/product-sales-analysis-i/

/*
Напишите решение, чтобы сообщить название продукта, год и цену для каждого идентификатора продажи в таблице продаж.

Верните полученную таблицу в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+ 
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+
Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+
Output: 
+--------------+-------+-------+
| product_name | year  | price |
+--------------+-------+-------+
| Nokia        | 2008  | 5000  |
| Nokia        | 2009  | 5000  |
| Apple        | 2011  | 9000  |
+--------------+-------+-------+
*/

SELECT
    product_name,
    year,
    price
FROM Sales
LEFT JOIN Product
ON Product.product_id = Sales.product_id;
-------------------------------------------------------------

--1179. Переформатировать таблицу отделов.
https://translate.google.nl/?hl=ru&sl=auto&tl=ru&text=%0A1179.%20Reformat%20Department%20Table&op=translate

/*
Переформатируйте таблицу таким образом, чтобы на каждом месяце был столбец идентификатора отдела и столбец доходов.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Department table:
+------+---------+-------+
| id   | revenue | month |
+------+---------+-------+
| 1    | 8000    | Jan   |
| 2    | 9000    | Jan   |
| 3    | 10000   | Feb   |
| 1    | 7000    | Feb   |
| 1    | 6000    | Mar   |
+------+---------+-------+
Output: 
+------+-------------+-------------+-------------+-----+-------------+
| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |
+------+-------------+-------------+-------------+-----+-------------+
| 1    | 8000        | 7000        | 6000        | ... | null        |
| 2    | 9000        | null        | null        | ... | null        |
| 3    | null        | 10000       | null        | ... | null        |
+------+-------------+-------------+-------------+-----+-------------+
*/

SELECT
    id,
    MAX(CASE WHEN month = 'Jan' THEN revenue END) AS Jan_Revenue,
    MAX(CASE WHEN month = 'Feb' THEN revenue END) AS Feb_Revenue,
    MAX(CASE WHEN month = 'Mar' THEN revenue END) AS Mar_Revenue,
    MAX(CASE WHEN month = 'Apr' THEN revenue END) AS Apr_Revenue,
    MAX(CASE WHEN month = 'May' THEN revenue END) AS May_Revenue,
    MAX(CASE WHEN month = 'Jun' THEN revenue END) AS Jun_Revenue,
    MAX(CASE WHEN month = 'Jul' THEN revenue END) AS Jul_Revenue,
    MAX(CASE WHEN month = 'Aug' THEN revenue END) AS Aug_Revenue,
    MAX(CASE WHEN month = 'Sep' THEN revenue END) AS Sep_Revenue,
    MAX(CASE WHEN month = 'Oct' THEN revenue END) AS Oct_Revenue,
    MAX(CASE WHEN month = 'Nov' THEN revenue END) AS Nov_Revenue,
    MAX(CASE WHEN month = 'Dec' THEN revenue END) AS Dec_Revenue
FROM Department
GROUP BY id;
---------------------------------------------------------------------------------

--1890. Последний вход в систему в 2020 году.
https://leetcode.com/problems/the-latest-login-in-2020/

/*
Напишите решение, чтобы сообщить о последнем входе для всех пользователей в 2020 году. Не включайте пользователей, которые не вошли в систему в 2020 году.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Logins table:
+---------+---------------------+
| user_id | time_stamp          |
+---------+---------------------+
| 6       | 2020-06-30 15:06:07 |
| 6       | 2021-04-21 14:06:06 |
| 6       | 2019-03-07 00:18:15 |
| 8       | 2020-02-01 05:10:53 |
| 8       | 2020-12-30 00:46:50 |
| 2       | 2020-01-16 02:49:50 |
| 2       | 2019-08-25 07:59:08 |
| 14      | 2019-07-14 09:00:00 |
| 14      | 2021-01-06 11:59:59 |
+---------+---------------------+
Output: 
+---------+---------------------+
| user_id | last_stamp          |
+---------+---------------------+
| 6       | 2020-06-30 15:06:07 |
| 8       | 2020-12-30 00:46:50 |
| 2       | 2020-01-16 02:49:50 |
+---------+---------------------+
*/

SELECT
    user_id,
    MAX(time_stamp) AS last_stamp
FROM Logins
WHERE time_stamp < '2021-01-01 00:00:00' AND time_stamp >= '2020-01-01 00:00:00'
GROUP BY user_id;
-----------------------------------------------------------

--1484. Группировка проданных товаров по дате
https://leetcode.com/problems/group-sold-products-by-the-date/

/*
Напишите решение, чтобы найти для каждой даты количество различных проданных продуктов и их названия.

Названия проданных продуктов для каждой даты должны быть отсортированы лексикографически.

Верните таблицу результатов, упорядоченную по sell_date.

Формат результата приведен в следующем примере.

Input: 
Activities table:
+------------+------------+
| sell_date  | product     |
+------------+------------+
| 2020-05-30 | Headphone  |
| 2020-06-01 | Pencil     |
| 2020-06-02 | Mask       |
| 2020-05-30 | Basketball |
| 2020-06-01 | Bible      |
| 2020-06-02 | Mask       |
| 2020-05-30 | T-Shirt    |
+------------+------------+
Output: 
+------------+----------+------------------------------+
| sell_date  | num_sold | products                     |
+------------+----------+------------------------------+
| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |
| 2020-06-01 | 2        | Bible,Pencil                 |
| 2020-06-02 | 1        | Mask                         |
+------------+----------+------------------------------+
*/

SELECT
  sell_date,
  COUNT(product) AS num_sold,
  STRING_AGG(product, ',' ORDER BY product) AS products
FROM (
  SELECT DISTINCT sell_date, product
  FROM Activities
) AS unique_products
GROUP BY sell_date
ORDER BY sell_date;
-----------------------------------------------------------------

--175. Объединить две таблицы
https://leetcode.com/problems/combine-two-tables/

/*
Напишите решение, чтобы сообщить имя, фамилию, город и состояние каждого человека в таблице Persons. Если адрес personId отсутствует в таблице Address, сообщите об этом null.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Person table:
+----------+----------+-----------+
| personId | lastName | firstName |
+----------+----------+-----------+
| 1        | Wang     | Allen     |
| 2        | Alice    | Bob       |
+----------+----------+-----------+
Address table:
+-----------+----------+---------------+------------+
| addressId | personId | city          | state      |
+-----------+----------+---------------+------------+
| 1         | 2        | New York City | New York   |
| 2         | 3        | Leetcode      | California |
+-----------+----------+---------------+------------+
Output: 
+-----------+----------+---------------+----------+
| firstName | lastName | city          | state    |
+-----------+----------+---------------+----------+
| Allen     | Wang     | Null          | Null     |
| Bob       | Alice    | New York City | New York |
+-----------+----------+---------------+----------+
*/

SELECT
    firstName,
    lastName,
    city,
    state
FROM Person
LEFT JOIN Address
USING(personId);
-------------------------------------------------------

--511. Анализ игрового процесса I.
https://leetcode.com/problems/game-play-analysis-i/

/*
Напишите решение, чтобы найти дату первого входа в систему для каждого игрока.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Activity table:
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+
Output: 
+-----------+-------------+
| player_id | first_login |
+-----------+-------------+
| 1         | 2016-03-01  |
| 2         | 2017-06-25  |
| 3         | 2016-03-02  |
+-----------+-------------+
*/

SELECT
    player_id,
    MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id;
-------------------------------------------------------

--1148. Просмотры статей I
https://leetcode.com/problems/article-views-i/

/*
Напишите решение, чтобы найти всех авторов, которые просмотрели хотя бы одну из своих собственных статей.

Возвращает таблицу результатов, отсортированую по идентификатору в порядке возрастания.

Формат результата приведен в следующем примере.

Input: 
Views table:
+------------+-----------+-----------+------------+
| article_id | author_id | viewer_id | view_date  |
+------------+-----------+-----------+------------+
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |
+------------+-----------+-----------+------------+
Output: 
+------+
| id   |
+------+
| 4    |
| 7    |
+------+
*/

SELECT
    DISTINCT(author_id) AS id
FROM Views
WHERE author_id = viewer_id;
----------------------------------------------------------

--577. Бонус сотруднику
https://leetcode.com/problems/employee-bonus/

/*
Напишите решение, чтобы сообщить имя и сумму бонуса каждого сотрудника с бонусом менее 1000.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Employee table:
+-------+--------+------------+--------+
| empId | name   | supervisor | salary |
+-------+--------+------------+--------+
| 3     | Brad   | null       | 4000   |
| 1     | John   | 3          | 1000   |
| 2     | Dan    | 3          | 2000   |
| 4     | Thomas | 3          | 4000   |
+-------+--------+------------+--------+
Bonus table:
+-------+-------+
| empId | bonus |
+-------+-------+
| 2     | 500   |
| 4     | 2000  |
+-------+-------+
Output: 
+------+-------+
| name | bonus |
+------+-------+
| Brad | null  |
| John | null  |
| Dan  | 500   |
+------+-------+
*/

SELECT
    name,
    bonus
FROM Employee
LEFT JOIN Bonus
USING(empId)
WHERE bonus < 1000 OR bonus IS NULL;
-----------------------------------------------

--610. Треугольное суждение
https://leetcode.com/problems/triangle-judgement/

/*
Сообщите для каждых трех отрезков линии, могут ли они образовывать треугольник.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Triangle table:
+----+----+----+
| x  | y  | z  |
+----+----+----+
| 13 | 15 | 30 |
| 10 | 20 | 15 |
+----+----+----+
Output: 
+----+----+----+----------+
| x  | y  | z  | triangle |
+----+----+----+----------+
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
+----+----+----+----------+
*/

SELECT
    *,
    CASE
        WHEN
        x + y > z AND
        x + z > y AND
        y + z > x 
        THEN 'Yes'
        ELSE 'No'
    END AS  triangle
FROM Triangle;
-------------------------------------------------------------

--620. Нескучные фильмы
620. Нескучные фильмы

/*
Напишите решение для сообщения о фильмах с нечетным идентификатором и описанием, которое не является "скучным".

Верните таблицу результатов, упорядоченную по рейтингу в порядке убывания.

Формат результата приведен в следующем примере.

Input: 
Cinema table:
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 1  | War        | great 3D    | 8.9    |
| 2  | Science    | fiction     | 8.5    |
| 3  | irish      | boring      | 6.2    |
| 4  | Ice song   | Fantacy     | 8.6    |
| 5  | House card | Interesting | 9.1    |
+----+------------+-------------+--------+
Output: 
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 5  | House card | Interesting | 9.1    |
| 1  | War        | great 3D    | 8.9    |
+----+------------+-------------+--------+
*/

SELECT
    *
FROM Cinema
WHERE id % 2 <> 0 AND description <> 'boring'
ORDER BY rating DESC;
--------------------------------------------------------

--1965. Сотрудники с пропавшей информацией
https://leetcode.com/problems/employees-with-missing-information/

/*
Напишите решение для сообщения об идентификаторах всех сотрудников с отсутствующей информацией. Информация о сотруднике отсутствует, если:

Имя сотрудника отсутствует, или

Зарплата сотрудника отсутствует.

Верните таблицу результатов, упорядоченную по employee_id в порядке возрастания.

Формат результата приведен в следующем примере.

Input: 
Employees table:
+-------------+----------+
| employee_id | name     |
+-------------+----------+
| 2           | Crew     |
| 4           | Haven    |
| 5           | Kristian |
+-------------+----------+
Salaries table:
+-------------+--------+
| employee_id | salary |
+-------------+--------+
| 5           | 76071  |
| 1           | 22517  |
| 4           | 63539  |
+-------------+--------+
Output: 
+-------------+
| employee_id |
+-------------+
| 1           |
| 2           |
+-------------+
*/

SELECT
    employee_id
FROM Employees
FULL JOIN Salaries
USING(employee_id)
WHERE name IS NULL OR salary IS NULL
ORDER BY employee_id;
-----------------------------------------------------

--1581. Клиент, который посетил, но не совершил никаких транзакций.
https://translate.google.nl/?hl=ru&sl=auto&tl=ru&text=1581.%20Customer%20Who%20Visited%20but%20Did%20Not%20Make%20Any%20Transactions&op=translate

/*
Input: 
Visits
+----------+-------------+
| visit_id | customer_id |
+----------+-------------+
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |
+----------+-------------+
Transactions
+----------------+----------+--------+
| transaction_id | visit_id | amount |
+----------------+----------+--------+
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |
+----------------+----------+--------+
Output: 
+-------------+----------------+
| customer_id | count_no_trans |
+-------------+----------------+
| 54          | 2              |
| 30          | 1              |
| 96          | 1              |
+-------------+----------------+
*/

SELECT
    customer_id,
    COUNT(customer_id) AS count_no_trans
FROM Visits
LEFT JOIN Transactions
USING(visit_id)
WHERE transaction_id IS NULL
GROUP BY customer_id;
-------------------------------------------------------

--1327. Перечислите продукты, заказанные за период
https://translate.google.nl/?hl=ru&sl=auto&tl=ru&text=1327.%20List%20the%20Products%20Ordered%20in%20a%20Period&op=translate

/*
Напишите решение, чтобы получить названия продуктов, у которых было заказано не менее 100 единиц в феврале 2020 года, и их количество.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Products table:
+-------------+-----------------------+------------------+
| product_id  | product_name          | product_category |
+-------------+-----------------------+------------------+
| 1           | Leetcode Solutions    | Book             |
| 2           | Jewels of Stringology | Book             |
| 3           | HP                    | Laptop           |
| 4           | Lenovo                | Laptop           |
| 5           | Leetcode Kit          | T-shirt          |
+-------------+-----------------------+------------------+
Orders table:
+--------------+--------------+----------+
| product_id   | order_date   | unit     |
+--------------+--------------+----------+
| 1            | 2020-02-05   | 60       |
| 1            | 2020-02-10   | 70       |
| 2            | 2020-01-18   | 30       |
| 2            | 2020-02-11   | 80       |
| 3            | 2020-02-17   | 2        |
| 3            | 2020-02-24   | 3        |
| 4            | 2020-03-01   | 20       |
| 4            | 2020-03-04   | 30       |
| 4            | 2020-03-04   | 60       |
| 5            | 2020-02-25   | 50       |
| 5            | 2020-02-27   | 50       |
| 5            | 2020-03-01   | 50       |
+--------------+--------------+----------+
Output: 
+--------------------+---------+
| product_name       | unit    |
+--------------------+---------+
| Leetcode Solutions | 130     |
| Leetcode Kit       | 100     |
+--------------------+---------+
*/

SELECT
    product_name,
    SUM(unit) AS unit
FROM Orders
LEFT JOIN Products USING(product_id)
WHERE
    EXTRACT(MONTH FROM order_date) = 2
    AND EXTRACT(YEAR FROM order_date) = 2020
GROUP BY product_name
HAVING SUM(unit) >= 100;
------------------------------------------------------

--1050. Актеры и режиссеры, сотрудничавшие минимум трижды.
https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/description/

/*
Напишите решение, чтобы найти все пары (actor_id, director_id), в которых актер сотрудничал с режиссером не менее трех раз.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
ActorDirector table:
+-------------+-------------+-------------+
| actor_id    | director_id | timestamp   |
+-------------+-------------+-------------+
| 1           | 1           | 0           |
| 1           | 1           | 1           |
| 1           | 1           | 2           |
| 1           | 2           | 3           |
| 1           | 2           | 4           |
| 2           | 1           | 5           |
| 2           | 1           | 6           |
+-------------+-------------+-------------+
Output: 
+-------------+-------------+
| actor_id    | director_id |
+-------------+-------------+
| 1           | 1           |
+-------------+-------------+
*/

SELECT
    actor_id,
    director_id
FROM ActorDirector
GROUP BY
    actor_id,
    director_id
HAVING COUNT(*) > 2;
-----------------------------------------------------------

--584. Найдите рефери клиента
https://leetcode.com/problems/find-customer-referee/description/

/*
Найдите имена клиентов, которые не указаны клиентом с идентификатором = 2.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Customer table:
+----+------+------------+
| id | name | referee_id |
+----+------+------------+
| 1  | Will | null       |
| 2  | Jane | null       |
| 3  | Alex | 2          |
| 4  | Bill | null       |
| 5  | Zack | 1          |
| 6  | Mark | 2          |
+----+------+------------+
Output: 
+------+
| name |
+------+
| Will |
| Jane |
| Bill |
| Zack |
+------+
*/

SELECT
    name
FROM Customer
WHERE referee_id <> 2 OR referee_id IS NULL;
---------------------------------------------------------------

--181. Сотрудники зарабатывают больше, чем их менеджеры.
https://leetcode.com/problems/employees-earning-more-than-their-managers/description/

/*
Напишите решение, чтобы найти сотрудников, которые зарабатывают больше, чем их менеджеры.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Employee table:
+----+-------+--------+-----------+
| id | name  | salary | managerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | Null      |
| 4  | Max   | 90000  | Null      |
+----+-------+--------+-----------+
Output: 
+----------+
| Employee |
+----------+
| Joe      |
+----------+
*/

SELECT
    e.name AS Employee
FROM Employee AS e
LEFT JOIN Employee AS manager
ON e.managerId = manager.id
WHERE e.salary > manager.salary;
--------------------------------------------------------

--1729. Найти количество последователей
https://leetcode.com/problems/find-followers-count/description/

/*
Напишите решение, которое для каждого пользователя вернет количество подписчиков.

Верните таблицу результатов, упорядоченную по user_id, в порядке возрастания.

Формат результата приведен в следующем примере.

Input: 
Followers table:
+---------+-------------+
| user_id | follower_id |
+---------+-------------+
| 0       | 1           |
| 1       | 0           |
| 2       | 0           |
| 2       | 1           |
+---------+-------------+
Output: 
+---------+----------------+
| user_id | followers_count|
+---------+----------------+
| 0       | 1              |
| 1       | 1              |
| 2       | 2              |
+---------+----------------+
*/

SELECT
    user_id,
    COUNT(follower_id) AS followers_count
FROM Followers
GROUP BY
    user_id
ORDER BY 
    user_id;
---------------------------------------------------------------

--183. Клиенты, которые никогда не заказывают
https://leetcode.com/problems/customers-who-never-order/submissions/1157601588/

/*
Напишите решение, чтобы найти всех клиентов, которые никогда ничего не заказывают.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Customers table:
+----+-------+
| id | name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
Orders table:
+----+------------+
| id | customerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
Output: 
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
*/

SELECT
    name AS Customers
FROM Customers
LEFT JOIN Orders
ON Customers.id = Orders.customerId
WHERE customerId IS NULL;
---------------------------------------------------------------

--595. Большие страны
https://leetcode.com/problems/big-countries/submissions/1157606931/

/*
Страна большая, если:

Он имеет площадь не менее трех миллионов (т.е. 3000000 км2), или

Его население составляет не менее двадцати пяти миллионов человек (т.е. 25000000 человек).

Напишите решение, чтобы найти название, население и площадь крупных стран.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
World table:
+-------------+-----------+---------+------------+--------------+
| name        | continent | area    | population | gdp          |
+-------------+-----------+---------+------------+--------------+
| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
| Albania     | Europe    | 28748   | 2831741    | 12960000000  |
| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
| Andorra     | Europe    | 468     | 78115      | 3712000000   |
| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
+-------------+-----------+---------+------------+--------------+
Output: 
+-------------+------------+---------+
| name        | population | area    |
+-------------+------------+---------+
| Afghanistan | 25500100   | 652230  |
| Algeria     | 37100000   | 2381741 |
+-------------+------------+---------+
*/

SELECT
    name,
    population,
    area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
------------------------------------------------------------------------

--1661. Среднее время процесса на машину
https://leetcode.com/problems/average-time-of-process-per-machine/

/*
Существует заводской веб-сайт, на котором есть несколько машин, каждая из которых выполняет одинаковое количество процессов. Напишите решение, чтобы найти среднее время, необходимое каждой машине для завершения процесса.

Время для завершения процесса - это временная метка "конча" за вычетом временной метки "начала". Среднее время рассчитывается на общее время завершения каждого процесса на машине, деленное на количество заполненных процессов.

Полученная таблица должна иметь machine_id вместе со средним временем обработки_time, которое должно быть округлено до 3 знаков после запятой.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Activity table:
+------------+------------+---------------+-----------+
| machine_id | process_id | activity_type | timestamp |
+------------+------------+---------------+-----------+
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |
+------------+------------+---------------+-----------+
Output: 
+------------+-----------------+
| machine_id | processing_time |
+------------+-----------------+
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |
+------------+-----------------+
*/

WITH process_times AS (
    SELECT
        machine_id,
        process_id,
        MAX(CASE WHEN activity_type = 'start' THEN timestamp END) AS start_time,
        MAX(CASE WHEN activity_type = 'end' THEN timestamp END) AS end_time
    FROM Activity
    GROUP BY machine_id, process_id
)

SELECT
    machine_id,
    ROUND(AVG(CAST(end_time - start_time AS numeric)), 3) AS processing_time
FROM process_times
GROUP BY machine_id;
-----------------------------------------------------------------------------------------

--607. Продавец
https://leetcode.com/problems/sales-person/submissions/1157635533/

/*
Напишите решение, чтобы найти имена всех продавцов, у которых не было заказов, связанных с компанией с названием "RED".

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
SalesPerson table:
+----------+------+--------+-----------------+------------+
| sales_id | name | salary | commission_rate | hire_date  |
+----------+------+--------+-----------------+------------+
| 1        | John | 100000 | 6               | 4/1/2006   |
| 2        | Amy  | 12000  | 5               | 5/1/2010   |
| 3        | Mark | 65000  | 12              | 12/25/2008 |
| 4        | Pam  | 25000  | 25              | 1/1/2005   |
| 5        | Alex | 5000   | 10              | 2/3/2007   |
+----------+------+--------+-----------------+------------+
Company table:
+--------+--------+----------+
| com_id | name   | city     |
+--------+--------+----------+
| 1      | RED    | Boston   |
| 2      | ORANGE | New York |
| 3      | YELLOW | Boston   |
| 4      | GREEN  | Austin   |
+--------+--------+----------+
Orders table:
+----------+------------+--------+----------+--------+
| order_id | order_date | com_id | sales_id | amount |
+----------+------------+--------+----------+--------+
| 1        | 1/1/2014   | 3      | 4        | 10000  |
| 2        | 2/1/2014   | 4      | 5        | 5000   |
| 3        | 3/1/2014   | 1      | 1        | 50000  |
| 4        | 4/1/2014   | 1      | 4        | 25000  |
+----------+------------+--------+----------+--------+
Output: 
+------+
| name |
+------+
| Amy  |
| Mark |
| Alex |
+------+
*/

SELECT DISTINCT sp.name
FROM SalesPerson sp
WHERE NOT EXISTS (
    SELECT 1
    FROM Orders o
    JOIN Company c ON o.com_id = c.com_id
    WHERE o.sales_id = sp.sales_id AND c.name = 'RED'
);
------------------------------------------------------------------

--586. Клиент, размещающий наибольшее количество заказов
https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/description/

/*
Напишите решение, чтобы найти номер клиента для клиента, который разместил наибольшее количество заказов.

Тестовые примеры генерируются таким образом, что ровно один клиент разместит больше заказов, чем любой другой клиент.

Формат результата приведен в следующем примере.

Input: 
Orders table:
+--------------+-----------------+
| order_number | customer_number |
+--------------+-----------------+
| 1            | 1               |
| 2            | 2               |
| 3            | 3               |
| 4            | 3               |
+--------------+-----------------+
Output: 
+-----------------+
| customer_number |
+-----------------+
| 3               |
+-----------------+
Объяснение: У клиента с номером 3 есть два заказа, что больше, чем у клиента 1 или 2, потому что у каждого из них только один заказ. Таким образом, результат - клиент_номер 3.
*/

SELECT
    customer_number
FROM Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;
-----------------------------------------

--1789. Первичное отделение для каждого сотрудника
https://leetcode.com/problems/primary-department-for-each-employee/submissions/1158385224/

/*

Primary_flag - это ENUM (категория) типа ('Y', 'N'). Если флаг "Y", отдел является основным отделом для сотрудника. Если флаг "N", отдел не является основным.

Сотрудники могут принадлежать к нескольким отделам. Когда сотрудник присоединяется к другим отделам, ему нужно решить, какой отдел является его основным отделом. Обратите внимание, что когда сотрудник принадлежит только одному отделу, его основной колонкой является "N".

Напишите решение, чтобы сообщить обо всех сотрудниках в их основном отделе. Для сотрудников, принадлежащих к одному отделу, сообщите об их единственном отделе.

Верните таблицу результатов в любом порядке.

Формат результата приведен в следующем примере.

Input: 
Employee table:
+-------------+---------------+--------------+
| employee_id | department_id | primary_flag |
+-------------+---------------+--------------+
| 1           | 1             | N            |
| 2           | 1             | Y            |
| 2           | 2             | N            |
| 3           | 3             | N            |
| 4           | 2             | N            |
| 4           | 3             | Y            |
| 4           | 4             | N            |
+-------------+---------------+--------------+
Output: 
+-------------+---------------+
| employee_id | department_id |
+-------------+---------------+
| 1           | 1             |
| 2           | 1             |
| 3           | 3             |
| 4           | 3             |
+-------------+---------------+
Explanation: 
*/

WITH PrimaryDepartments AS (
    SELECT 
        employee_id, 
        CASE 
            WHEN COUNT(DISTINCT department_id) = 1 THEN MIN(department_id) 
            ELSE MAX(CASE WHEN primary_flag = 'Y' THEN department_id ELSE NULL END) 
        END AS primary_department
    FROM 
        Employee
    GROUP BY 
        employee_id
)
SELECT 
    employee_id, 
    primary_department AS department_id
FROM 
    PrimaryDepartments
WHERE 
    primary_department IS NOT NULL;
---------------------------------------------------------------------------

--1075. Сотрудники проекта I
https://leetcode.com/problems/project-employees-i/submissions/1158398923/

/*
Напишите SQL-запрос, в котором сообщается о среднем опыте всех сотрудников для каждого проекта, округленный до 2 цифр.

Верните таблицу результатов в любом порядке.

Формат результата запроса приведен в следующем примере.

Input: 
Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+
Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+
Output: 
+-------------+---------------+
| project_id  | average_years |
+-------------+---------------+
| 1           | 2.00          |
| 2           | 2.50          |
+-------------+---------------+
Explanation: The average experie
*/

SELECT
    DISTINCT(project_id),
    ROUND(AVG(experience_years) OVER (PARTITION BY project_id), 2) AS average_years
FROM Project
LEFT JOIN Employee
USING(employee_id);
-------------------------------------------------------

--1667. Исправить имена в таблице
https://leetcode.com/problems/fix-names-in-a-table/

/*
Напишите решение, чтобы исправить имена так, чтобы только первый символ был в верхнем регистре, а остальные - в нижнем регистре.

Возвращает таблицу результатов, упорядоченную по user_id.

Формат результата приведен в следующем примере.

Input: 
Users table:
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | aLice |
| 2       | bOB   |
+---------+-------+
Output: 
+---------+-------+
| user_id | name  |
+---------+-------+
| 1       | Alice |
| 2       | Bob   |
+---------+-------+
*/

SELECT 
    user_id, 
    CONCAT(UPPER(SUBSTRING(name, 1, 1)), LOWER(SUBSTRING(name, 2))) AS name
FROM Users
ORDER BY user_id;
-------------------------------------------

--196. Удалить повторяющиеся электронные письма
https://translate.google.nl/?hl=ru&sl=auto&tl=ru&text=196.%20Delete%20Duplicate%20Emails&op=translate

/*
PostgreSQL

Напишите решение для удаления всех дубликатов электронных писем, сохранив только одно уникальное электронное письмо с наименьшим идентификатором.

Для пользователей SQL, пожалуйста, обратите внимание, что вы должны написать инструкцию DELETE, а не SELECT.

После запуска вашего сценария показанный ответ - таблица "Человек". Драйвер сначала скомпилирует и запустите ваш фрагмент кода, а затем покажет таблицу Person. Окончательный порядок стола Person не имеет значения.

Формат результата приведен в следующем примере.

Input: 
Person table:
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Output: 
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
*/

DELETE FROM Person
WHERE id NOT IN (
    SELECT MIN(id)
    FROM Person
    GROUP BY email
);
-------------------------------------------------

--619. Самое большое одиночное число.
https://leetcode.com/problems/biggest-single-number/submissions/1158420634/

/*
Одно число - это число, которое появилось только один раз в таблице MyNumbers.

Найдите самое большое одно число. Если нет единого номера, сообщите null.

Формат результата приведен в следующем примере.

Input: 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 3   |
| 3   |
| 1   |
| 4   |
| 5   |
| 6   |
+-----+
Output: 
+-----+
| num |
+-----+
| 6   |
+-----+
Explanation: The single numbers are 1, 4, 5, and 6.
Since 6 is the largest single number, we return it.
Example 2:

Input: 
MyNumbers table:
+-----+
| num |
+-----+
| 8   |
| 8   |
| 7   |
| 7   |
| 3   |
| 3   |
| 3   |
+-----+
Output: 
+------+
| num  |
+------+
| null |
+------+
Explanation: There are no single numbers in the input table so we return null.
*/

SELECT MAX(num) AS num
FROM (
    SELECT num
    FROM MyNumbers
    GROUP BY num
    HAVING COUNT(num) = 1
) AS SingleNumbers;

----------------
WITH SingleNumbers AS (
    SELECT num
    FROM MyNumbers
    GROUP BY num
    HAVING COUNT(num) = 1
)
SELECT MAX(num) AS num
FROM SingleNumbers;
----------------------------------------------------------------------